package @{packageName};

import java.io.InputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import net.vvakame.util.jsonpullparser.JsonFormatException;
import net.vvakame.util.jsonpullparser.JsonPullParser;
import net.vvakame.util.jsonpullparser.JsonPullParser.State;
import net.vvakame.util.jsonpullparser.util.OnJsonObjectAddListener;

/**
 * JSONを {@link JsonPullParser} を用いて {@link @{target}} に変換するクラスです.<br>
 * APTにより自動生成されています.
 */
public class @{target}@{postfix} {

	/**
	 * JSONを {@link @{target}} の {@link List} に変換します.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @return {@link @{target}} の {@link List}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static List<@{target}> getList(String json) throws IOException, IllegalStateException, JsonFormatException {
		JsonPullParser parser = JsonPullParser.newParser(json);
		return getList(parser, null);
	}

	/**
	 * JSONを {@link @{target}} の {@link List} に変換します.<br>
	 * {@link OnJsonObjectAddListener} のサブクラスを渡すことにより、生成中に発生する各種インスタンスを逐次うけとることが可能です.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @param listener {@link @{target}} 生成中に発生するインスタンスを逐次受け取る {@link OnJsonObjectAddListener} のサブクラス
	 * @return {@link @{target}} の {@link List}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static List<@{target}> getList(String json, OnJsonObjectAddListener listener) throws IOException, IllegalStateException, JsonFormatException {
		JsonPullParser parser = JsonPullParser.newParser(json);
		return getList(parser, listener);
	}

	/**
	 * JSONを {@link @{target}} の {@link List} に変換します.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @return {@link @{target}} の {@link List}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static List<@{target}> getList(InputStream stream) throws IOException, IllegalStateException, JsonFormatException {
		JsonPullParser parser = JsonPullParser.newParser(stream);
		return getList(parser, null);
	}

	/**
	 * JSONを {@link @{target}} の {@link List} に変換します.<br>
	 * {@link OnJsonObjectAddListener} のサブクラスを渡すことにより、生成中に発生する各種インスタンスを逐次うけとることが可能です.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @param listener {@link @{target}} 生成中に発生するインスタンスを逐次受け取る {@link OnJsonObjectAddListener} のサブクラス
	 * @return {@link @{target}} の {@link List}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static List<@{target}> getList(InputStream stream, OnJsonObjectAddListener listener) throws IOException, IllegalStateException, JsonFormatException {
		JsonPullParser parser = JsonPullParser.newParser(stream);
		return getList(parser, listener);
	}

	/**
	 * JSONを {@link @{target}} の {@link List} に変換します.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @return {@link @{target}} の {@link List}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static List<@{target}> getList(JsonPullParser parser) throws IOException, IllegalStateException, JsonFormatException {
		return getList(parser, null);
	}

	/**
	 * JSONを {@link @{target}} の {@link List} に変換します.<br>
	 * {@link OnJsonObjectAddListener} のサブクラスを渡すことにより、生成中に発生する各種インスタンスを逐次うけとることが可能です.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @param listener {@link @{target}} 生成中に発生するインスタンスを逐次受け取る {@link OnJsonObjectAddListener} のサブクラス
	 * @return {@link @{target}} の {@link List}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static List<@{target}> getList(JsonPullParser parser, OnJsonObjectAddListener listener) throws IOException, IllegalStateException, JsonFormatException {
		List<@{target}> list = new ArrayList<@{target}>();
		State eventType = parser.getEventType();
		if (eventType == State.VALUE_NULL) {
			return null;
		}
		if (eventType != State.START_ARRAY) {
			throw new IllegalStateException("not started brace!");
		}
		while (parser.lookAhead() != State.END_ARRAY) {
			@{target} tmp = get(parser, listener);
			list.add(tmp);
		}
		parser.getEventType();
		return list;
	}

	/**
	 * JSONを {@link @{target}} に変換します.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @return {@link @{target}}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static @{target} get(String json) throws IOException, IllegalStateException, JsonFormatException {
		JsonPullParser parser = JsonPullParser.newParser(json);
		return get(parser, null);
	}

	/**
	 * JSONを {@link @{target}} に変換します.<br>
	 * {@link OnJsonObjectAddListener} のサブクラスを渡すことにより、生成中に発生する各種インスタンスを逐次うけとることが可能です.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @param listener {@link @{target}} 生成中に発生するインスタンスを逐次受け取る {@link OnJsonObjectAddListener} のサブクラス
	 * @return {@link @{target}}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static @{target} get(String json, OnJsonObjectAddListener listener) throws IOException, IllegalStateException, JsonFormatException {
		JsonPullParser parser = JsonPullParser.newParser(json);
		return get(parser, listener);
	}

	/**
	 * JSONを {@link @{target}} に変換します.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @return {@link @{target}}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static @{target} get(InputStream stream) throws IOException, IllegalStateException, JsonFormatException {
		JsonPullParser parser = JsonPullParser.newParser(stream);
		return get(parser, null);
	}

	/**
	 * JSONを {@link @{target}} に変換します.<br>
	 * {@link OnJsonObjectAddListener} のサブクラスを渡すことにより、生成中に発生する各種インスタンスを逐次うけとることが可能です.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @param listener {@link @{target}} 生成中に発生するインスタンスを逐次受け取る {@link OnJsonObjectAddListener} のサブクラス
	 * @return {@link @{target}}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static @{target} get(InputStream stream, OnJsonObjectAddListener listener) throws IOException, IllegalStateException, JsonFormatException {
		JsonPullParser parser = JsonPullParser.newParser(stream);
		return get(parser, listener);
	}

	/**
	 * JSONを {@link @{target}} に変換します.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @return {@link @{target}}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static @{target} get(JsonPullParser parser) throws IOException, IllegalStateException, JsonFormatException {
		return get(parser, null);
	}

	/**
	 * JSONを {@link @{target}} に変換します.<br>
	 * {@link OnJsonObjectAddListener} のサブクラスを渡すことにより、生成中に発生する各種インスタンスを逐次うけとることが可能です.
	 * 
	 * @param json JSONによる {@link @{target}} の表現
	 * @param listener {@link @{target}} 生成中に発生するインスタンスを逐次受け取る {@link OnJsonObjectAddListener} のサブクラス
	 * @return {@link @{target}}
	 * @throws JsonFormatException JSONとして正しくない形式だった場合に投げられます
	 * @throws IllegalStateException JSONとしては正しくても {@link @{target}} に合致しない場合に投げられます
	 */
	public static @{target} get(JsonPullParser parser, OnJsonObjectAddListener listener) throws IOException, IllegalStateException, JsonFormatException {
		@{target} obj = new @{target}();
		State eventType = parser.getEventType();
		if (eventType == State.VALUE_NULL) {
			return null;
		}
		if (eventType != State.START_HASH) {
			throw new IllegalStateException("not started hash brace!");
		}
		while ((eventType = parser.getEventType()) != State.END_HASH) {
			if (eventType != State.KEY) {
				throw new IllegalStateException("expect KEY. we got unexpected value. " + eventType);
			}
			String key = parser.getValueString();
			@foreach{obj : elements}if ("@{obj.key}".equals(key)) {
@if{obj.kind == "BOOLEAN"}
				parser.getEventType();
				obj.@{obj.setter}(parser.getValueBoolean());
@else{obj.kind == "CHAR"}
				parser.getEventType();
				obj.@{obj.setter}(parser.getValueString().charAt(0));
@else{obj.kind == "BYTE"}
				parser.getEventType();
				obj.@{obj.setter}((byte)parser.getValueLong());
@else{obj.kind == "SHORT"}
				parser.getEventType();
				obj.@{obj.setter}((short)parser.getValueLong());
@else{obj.kind == "INT"}
				parser.getEventType();
				obj.@{obj.setter}((int)parser.getValueLong());
@else{obj.kind == "LONG"}
				parser.getEventType();
				obj.@{obj.setter}(parser.getValueLong());
@else{obj.kind == "FLOAT"}
				parser.getEventType();
				obj.@{obj.setter}((float)parser.getValueDouble());
@else{obj.kind == "DOUBLE"}
				parser.getEventType();
				obj.@{obj.setter}(parser.getValueDouble());
@else{obj.kind == "STRING"}
				parser.getEventType();
				obj.@{obj.setter}(parser.getValueString());
@else{obj.kind == "LIST"}
				obj.@{obj.setter}(@{obj.modelName}@{postfix}.getList(parser));
@else{obj.kind == "JSON_ARRAY"}
				obj.@{obj.setter}(net.vvakame.util.jsonpullparser.util.JsonArray.fromParser(parser));
@else{obj.kind == "JSON_HASH"}
				obj.@{obj.setter}(net.vvakame.util.jsonpullparser.util.JsonHash.fromParser(parser));
@else{obj.kind == "MODEL"}
				@{obj.modelName} tmp = @{obj.modelName}@{postfix}.get(parser);
				obj.@{obj.setter}(tmp);
				if (listener != null) {
					listener.onAdd(tmp);
				}
@else{obj.kind == "CONVERTER"}
				@{obj.converter} converter = @{obj.converter}.getInstance();
				@{obj.modelName} tmp = converter.parse(parser);
				obj.@{obj.setter}(tmp);
@end{}@end{'			} else '}
@if{elements.size() != 0}
@if{treatUnknownKeyAsError == true}
			} else {
				throw new IllegalStateException("unsupported key. key=" + key);
			}
@else{}
			} else {
				parser.discardValue();
			}
@end{}
@end{}
		}

		if (listener != null) {
			listener.onAdd(obj);
		}

		return obj;
	}
}